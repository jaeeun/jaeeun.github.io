---
layout : compress
title : Face Tracking
---

<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js"><!--<![endif]-->

<head>
	{% include head.html %}
</head>

<body>
	{% include nav.html %}

	<header class="header" role="banner">
		<div class="wrapper animated fadeIn">
			<div class="content">
				<div class="post-title {% if page.feature %} feature {% endif %}">
					<h1>{{ page.title }}</h1>

					<a class="btn zoombtn" onClick="history.go(-1)">
						<i class="fa fa-chevron-left"></i>
					</a>
				</div>

				<canvas id="canvas" width="700" height="500"></canvas>

				<div id="info">
					<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - morph targets -
					webcam<br />
					model by <a href="https://www.bannaflak.com/face-cap" target="_blank" rel="noopener">Face Cap</a>
				</div>

				<!-- Import maps polyfill -->
				<!-- Remove this when import maps will be widely supported -->
				<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

				<script type="importmap">
					{
						"imports": {
							"three": "https://unpkg.com/three@0.141.0/build/three.module.js",
							"three/addons/": "https://unpkg.com/three@0.141.0/examples/jsm/"
						}
					}
				</script>

				<script type="module">

					import * as THREE from 'three';

					import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
					import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

					import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
					import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
					import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';

					import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

					import vision from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';

					const { FaceLandmarker, FilesetResolver } = vision;

					const blendshapesMap = {
						'browDownLeft': 'browDown_L',
						'browDownRight': 'browDown_R',
						'browInnerUp': 'browInnerUp',
						'browOuterUpLeft': 'browOuterUp_L',
						'browOuterUpRight': 'browOuterUp_R',
						'cheekPuff': 'cheekPuff',
						'cheekSquintLeft': 'cheekSquint_L',
						'cheekSquintRight': 'cheekSquint_R',
						'eyeBlinkLeft': 'eyeBlink_L',
						'eyeBlinkRight': 'eyeBlink_R',
						'eyeLookDownLeft': 'eyeLookDown_L',
						'eyeLookDownRight': 'eyeLookDown_R',
						'eyeLookInLeft': 'eyeLookIn_L',
						'eyeLookInRight': 'eyeLookIn_R',
						'eyeLookOutLeft': 'eyeLookOut_L',
						'eyeLookOutRight': 'eyeLookOut_R',
						'eyeLookUpLeft': 'eyeLookUp_L',
						'eyeLookUpRight': 'eyeLookUp_R',
						'eyeSquintLeft': 'eyeSquint_L',
						'eyeSquintRight': 'eyeSquint_R',
						'eyeWideLeft': 'eyeWide_L',
						'eyeWideRight': 'eyeWide_R',
						'jawForward': 'jawForward',
						'jawLeft': 'jawLeft',
						'jawOpen': 'jawOpen',
						'jawRight': 'jawRight',
						'mouthClose': 'mouthClose',
						'mouthDimpleLeft': 'mouthDimple_L',
						'mouthDimpleRight': 'mouthDimple_R',
						'mouthFrownLeft': 'mouthFrown_L',
						'mouthFrownRight': 'mouthFrown_R',
						'mouthFunnel': 'mouthFunnel',
						'mouthLeft': 'mouthLeft',
						'mouthLowerDownLeft': 'mouthLowerDown_L',
						'mouthLowerDownRight': 'mouthLowerDown_R',
						'mouthPressLeft': 'mouthPress_L',
						'mouthPressRight': 'mouthPress_R',
						'mouthPucker': 'mouthPucker',
						'mouthRight': 'mouthRight',
						'mouthRollLower': 'mouthRollLower',
						'mouthRollUpper': 'mouthRollUpper',
						'mouthShrugLower': 'mouthShrugLower',
						'mouthShrugUpper': 'mouthShrugUpper',
						'mouthSmileLeft': 'mouthSmile_L',
						'mouthSmileRight': 'mouthSmile_R',
						'mouthStretchLeft': 'mouthStretch_L',
						'mouthStretchRight': 'mouthStretch_R',
						'mouthUpperUpLeft': 'mouthUpperUp_L',
						'mouthUpperUpRight': 'mouthUpperUp_R',
						'noseSneerLeft': 'noseSneer_L',
						'noseSneerRight': 'noseSneer_R',
					};


					const renderer = new THREE.WebGLRenderer({
						canvas: document.querySelector('#canvas'),
						antialias: true
					});

					renderer.toneMapping = THREE.ACESFilmicToneMapping;

					const camera = new THREE.PerspectiveCamera(60, 700 / 500, 1, 100);
					camera.position.z = 5;

					const scene = new THREE.Scene();
					scene.scale.x = - 1;

					const environment = new RoomEnvironment();
					const pmremGenerator = new THREE.PMREMGenerator(renderer);

					scene.background = new THREE.Color(0x666666);
					scene.environment = pmremGenerator.fromScene(environment).texture;

					const controls = new OrbitControls(camera, renderer.domElement);


					const ktx2Loader = new KTX2Loader()
						.setTranscoderPath('../../../libs/basis/')
						.detectSupport(renderer);

					new GLTFLoader()
						.setKTX2Loader(ktx2Loader)
						.setMeshoptDecoder(MeshoptDecoder)
						.load('../../../assets/GLTF/facecap.glb', (gltf) => {

							const mesh = gltf.scene.children[0];
							scene.add(mesh);

							const head = mesh.getObjectByName('mesh_2');
							head.material = new THREE.MeshNormalMaterial();


							const gui = new GUI();
							gui.open();

							const influences = head.morphTargetInfluences;

							for (const [key, value] of Object.entries(head.morphTargetDictionary)) {

								gui.add(influences, value, 0, 1, 0.01)
									.name(key.replace('blendShape1.', ''))
									.listen(influences);

							}

							renderer.setAnimationLoop(animation);

						});


					const video = document.createElement('video');

					const texture = new THREE.VideoTexture(video);
					texture.colorSpace = THREE.SRGBColorSpace;

					const geometry = new THREE.PlaneGeometry(1, 1);
					const material = new THREE.MeshBasicMaterial({ map: texture, depthWrite: false });
					const videomesh = new THREE.Mesh(geometry, material);
					scene.add(videomesh);

					const filesetResolver = await FilesetResolver.forVisionTasks(
						'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm'
					);

					const faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
						baseOptions: {
							modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
							delegate: 'GPU'
						},
						outputFaceBlendshapes: true,
						outputFacialTransformationMatrixes: true,
						runningMode: 'VIDEO',
						numFaces: 1
					});

					if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {

						navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } })
							.then(function (stream) {

								video.srcObject = stream;
								video.play();

							})
							.catch(function (error) {

								console.error('Unable to access the camera/webcam.', error);

							});

					}

					const transform = new THREE.Object3D();

					function animation() {

						if (video.readyState >= HTMLMediaElement.HAVE_METADATA) {

							const results = faceLandmarker.detectForVideo(video, Date.now());

							if (results.facialTransformationMatrixes.length > 0) {

								const facialTransformationMatrixes = results.facialTransformationMatrixes[0].data;

								transform.matrix.fromArray(facialTransformationMatrixes);
								transform.matrix.decompose(transform.position, transform.quaternion, transform.scale);

								const object = scene.getObjectByName('grp_transform');

								object.position.x = transform.position.x;
								object.position.y = transform.position.z + 40;
								object.position.z = - transform.position.y;

								object.rotation.x = transform.rotation.x;
								object.rotation.y = transform.rotation.z;
								object.rotation.z = - transform.rotation.y;

							}

							if (results.faceBlendshapes.length > 0) {

								const face = scene.getObjectByName('mesh_2');

								const faceBlendshapes = results.faceBlendshapes[0].categories;

								for (const blendshape of faceBlendshapes) {

									const categoryName = blendshape.categoryName;
									const score = blendshape.score;

									const index = face.morphTargetDictionary[blendshapesMap[categoryName]];

									if (index !== undefined) {

										face.morphTargetInfluences[index] = score;

									}

								}

							}

						}

						videomesh.scale.x = video.videoWidth / 100;
						videomesh.scale.y = video.videoHeight / 100;

						renderer.render(scene, camera);

						controls.update();
						

					}

					window.addEventListener('resize', function () {

						camera.aspect = window.innerWidth / window.innerHeight;
						camera.updateProjectionMatrix();

						renderer.setSize(window.innerWidth, window.innerHeight);

					});

				</script>
			</div>
		</div>
	</header>
	{% include scripts.html %}
</body>

</html>